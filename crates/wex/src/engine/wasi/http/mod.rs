//! # Wex's WASI HTTP Implementation

mod body;
mod client;
mod conv;
mod host;
mod proxy;
mod request;
mod response;

pub use body::*;
pub use client::*;
pub use request::*;
pub use response::*;

use std::sync::Arc;

use bytes::Bytes;
use http_body_util::combinators::BoxBody;
use tokio::sync::{
    mpsc::{self, UnboundedSender},
    oneshot, Mutex, OwnedSemaphorePermit, Semaphore,
};
use wasmtime::component::{Linker, ResourceTable};

pub use crate::engine::bindings::wasi::http::types::ErrorCode;

use crate::engine::ResourceView;

#[derive(Debug)]
pub struct ResponseOutparam {
    pub response: oneshot::Sender<Result<http::Response<()>, ErrorCode>>,
    pub body: OutgoingBodySender,
}

pub struct FutureIncomingResponse;

pub enum FutureTrailers {
    Body(BoxBody<Bytes, ErrorCode>),
    Ready(http::HeaderMap),
}

/// Add all WASI interfaces from this module into the `linker` provided.
pub fn add_to_linker<T>(l: &mut Linker<T>) -> anyhow::Result<()>
where
    T: WasiHttpView,
{
    use crate::engine::bindings::wasi::http;

    let closure = type_annotate_http::<T, _>(|t| WasiHttpImpl(t));
    http::outgoing_handler::add_to_linker_get_host(l, closure)?;
    http::types::add_to_linker_get_host(l, &http::types::LinkOptions::default(), closure)?;
    Ok(())
}

// NB: workaround some rustc inference - a future refactoring may make this
// obsolete.
fn type_annotate_http<T, F>(val: F) -> F
where
    F: Fn(&mut T) -> WasiHttpImpl<&mut T>,
{
    val
}

/// A concrete structure that all generated `Host` traits are implemented for.
///
/// This type serves as a small newtype wrapper to implement all of the `Host`
/// traits for `wasi:http`. This type is internally used and is only needed if
/// you're interacting with `add_to_linker` functions generated by bindings
/// themselves (or `add_to_linker_get_host`).
///
/// This type is automatically used when using
/// [`add_to_linker`](crate::p3::add_to_linker)
#[repr(transparent)]
pub struct WasiHttpImpl<T>(pub T);

impl<T: WasiHttpView> WasiHttpView for &mut T {
    type Client = T::Client;

    fn http(&self) -> &WasiHttpCtx<Self::Client> {
        (**self).http()
    }

    fn is_forbidden_header(&mut self, name: &http::header::HeaderName) -> bool {
        (**self).is_forbidden_header(name)
    }
}

impl<T: WasiHttpView> WasiHttpView for WasiHttpImpl<T> {
    type Client = T::Client;

    fn http(&self) -> &WasiHttpCtx<Self::Client> {
        self.0.http()
    }

    fn is_forbidden_header(&mut self, name: &http::header::HeaderName) -> bool {
        self.0.is_forbidden_header(name)
    }
}

impl<T: ResourceView> ResourceView for WasiHttpImpl<T> {
    fn table(&mut self) -> &mut ResourceTable {
        self.0.table()
    }
}

/// Default byte buffer capacity to use
const DEFAULT_BUFFER_CAPACITY: usize = 1 << 13;

/// Set of [http::header::HeaderName], that are forbidden by default
/// for requests and responses originating in the guest.
pub const DEFAULT_FORBIDDEN_HEADERS: [http::header::HeaderName; 10] = [
    http::header::CONNECTION,
    http::header::HeaderName::from_static("keep-alive"),
    http::header::PROXY_AUTHENTICATE,
    http::header::PROXY_AUTHORIZATION,
    http::header::HeaderName::from_static("proxy-connection"),
    http::header::TE,
    http::header::TRANSFER_ENCODING,
    http::header::UPGRADE,
    http::header::HOST,
    http::header::HeaderName::from_static("http2-settings"),
];

/// A trait which provides internal WASI HTTP state.
pub trait WasiHttpView: ResourceView + Send {
    /// HTTP client
    type Client: Client;

    /// Returns a reference to [WasiHttpCtx]
    fn http(&self) -> &WasiHttpCtx<Self::Client>;

    /// Whether a given header should be considered forbidden and not allowed
    /// for requests and responses originating in the guest.
    /// Note: headers of incoming requests and responses are not validated.
    fn is_forbidden_header(&mut self, name: &http::header::HeaderName) -> bool {
        DEFAULT_FORBIDDEN_HEADERS.contains(name)
    }
}

/// Capture the state necessary for use in the wasi-http API implementation.
#[derive(Clone, Debug, Default)]
pub struct WasiHttpCtx<C = DefaultClient>
where
    C: Client,
{
    /// HTTP client
    pub client: C,
}
